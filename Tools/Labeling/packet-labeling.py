import pyshark
import re
from queue import Queue
from threading import Thread
from hpack import Decoder


def decode_http2_headers(raw_headers):
    """Decode HPACK-compressed HTTP/2 headers."""
    decoder = Decoder()
    try:
        headers = decoder.decode(raw_headers)
        return headers
    except Exception as e:
        return None


def process_packet(packet_queue, output_file):
    """Process packets in a separate thread to avoid dropping packets."""
    with open(output_file, 'w') as output:
        output.write("timestamp,source_ip,destination_ip,http_payload,protocol\n")
        
        while True:
            packet = packet_queue.get()
            if packet is None:  # Exit signal
                break
            try:
                src_ip = packet.ip.src
                dst_ip = packet.ip.dst

                if hasattr(packet, 'http2'):

                    if 'headers' in packet.http2.field_names:
                        # decoding the http2 header cause normaly it's in bytes
                        raw_headers = bytes.fromhex(packet.http2.headers.replace(":", ""))
                        headers = decode_http2_headers(raw_headers)
                        if headers:
                            for name, value in headers:
                                if name.lower() == "content-type" :
                                    if "application/dns-message" in value.lower() or "application/dns-json" in value.lower():
                                        timestamp = packet.sniff_time
                                        protocol = "DNS-over-HTTPS"
                                        http_payload = getattr(packet.http2, 'file_data', "No payload")
                                        output.write(f"{timestamp},{src_ip},{dst_ip},{http_payload},{protocol}\n")
                                        print(f"Decrypted DoH packet: {packet.http2}")
            except AttributeError:
                continue


def capture_and_decrypt(interface, ssl_keylog_file, output_file):
    capture = pyshark.LiveCapture(
        interface=interface,
        bpf_filter="port 443",  # Capture only HTTPS traffic (port 443)
        override_prefs={"tls.keylog_file": ssl_keylog_file}  # Use SSL key log file for decryption
    )

    # Queue for thread-safe packet processing
    packet_queue = Queue()
    processor_thread = Thread(target=process_packet, args=(packet_queue, output_file))
    processor_thread.start()

    try:
        for packet in capture.sniff_continuously():
            packet_queue.put(packet)
    except KeyboardInterrupt:
        print("Stopping capture...")

    # Signal the processing thread to exit
    packet_queue.put(None)
    processor_thread.join()


if __name__ == "__main__":
    # Configuration
    interface = "enp0s1"  # Replace with your network interface
    ssl_keylog_file = "./sslkeys.log"  # SSL key log file (generated by Firefox)
    output_file = "doh_decrypted_traffic.csv"

    # Start capturing and decrypting
    capture_and_decrypt(interface, ssl_keylog_file, output_file)
